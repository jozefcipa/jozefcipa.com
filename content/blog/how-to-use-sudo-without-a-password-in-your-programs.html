---
title: How to use sudo without a password in your programs
tags:
  - golang
  - scripting
date: '2025-01-14T19:51:47.208Z'
slug: how-to-use-sudo-without-a-password-in-your-programs
draft: false
---

<article id="17077955-515e-80e9-b1f2-c0565db4b3fb" class="page sans"><div class="page-body"><p id="17a77955-515e-80bf-9d30-fcfe879da0d8" class="">When writing software, sometimes it is necessary to run shell commands that require sudo privileges. This can happen, for instance, when building a CLI tool that needs to write into protected filesystem directories or modify certain files. Such commands are usually prepended with the <code>sudo</code> keyword which is then followed by a password prompt. This is very important from the security perspective, so the OS can protect sensitive data. However, sometimes it might become annoying when using a tool that constantly asks for a password.</p><p id="17a77955-515e-804a-bde7-e917dce84cfb" class="">Luckily, there’s a solution for that - a <code>sudoers</code> file.</p><h2 id="17a77955-515e-808d-a3dd-ca9dca4c41a7" class="">What is a sudoers file?</h2><p id="17677955-515e-80d0-920b-c493253d28ca" class="">The <em>sudoers</em> file is a special configuration file in Linux (and macOS) that controls who can use the <code>sudo</code> command and what commands are they allowed to run with superuser (<code>root</code>) privileges. This configuration is located in the <code>/etc/sudoers</code> file or it can consist of multiple files created in the <code>/etc/sudoers.d</code> directory.</p><p id="17a77955-515e-80f9-9bb4-d46b9108308e" class="">Using this file we can allow or deny specific users (or groups) to run certain commands, manage <em>sudo</em> access, grant password-less access, etc.<br>In this article, we will explore the last mentioned option - password-less <br><em>sudo</em> access.</p><h2 id="17a77955-515e-8068-8fc6-e14cde69ca97" class="">Let’s see it in practice</h2><p id="17b77955-515e-80cb-af5f-f7df1c6d9b34" class="">We can demonstrate the power of <em>sudoers</em> in the following example. Let’s say we want to see whether port 80 is used on our machine. For that, we can use the <code>lsof</code> command:</p><pre id="17b77955-515e-809c-99fa-cf9957880055" class="code"><code class="language-Bash">$ sudo lsof -nP -i4:80
Password:</code></pre><p id="17b77955-515e-803a-a033-cb34ffea12f3" class="">As expected, this results in a <em>sudo</em> password prompt (<em>Note: you can also use </em><em><code>lsof</code></em><em> without sudo but then you will only see your processes</em>).</p><p id="17b77955-515e-800a-b8a4-cab91fe8a767" class="">Now, let’s create a test <em>sudoers</em> file. Note, that it is important to always edit the <em>sudoers</em> file with <code>visudo</code> as it always verifies the syntax of the file. Otherwise, it can happen that a mistake in <em>sudoers</em> may cause <em>sudo</em> to stop working.</p><pre id="17b77955-515e-80d8-b206-d3ad1fdb9e79" class="code"><code class="language-Bash">$ sudo visudo /etc/sudoers.d/test</code></pre><p id="17b77955-515e-8084-9112-f1cb0f952993" class="">And put the following config inside:</p><pre id="17b77955-515e-80f7-acda-ebb6a928ded4" class="code"><code class="language-Bash">jozefcipa ALL=(ALL) NOPASSWD: /usr/sbin/lsof</code></pre><p id="17b77955-515e-80c3-9bbb-f34907f46b1f" class="">This says that the user <code>jozefcipa</code> can run <code>/usr/sbin/lsof</code> command without the <em>sudo</em> password. If we run the command again, we should get the result without being asked for the password.</p><pre id="17b77955-515e-8019-9d99-c094def905c4" class="code"><code class="language-Bash">$ sudo lsof -nP -i4:80
COMMAND   PID      USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
nginx   30212 jozefcipa    9u  IPv4 0xf57eb0bdeadfecb1      0t0  TCP *:80 (LISTEN)</code></pre><p id="17b77955-515e-809f-a778-e853e45b2d70" class="">That was quite easy, but this configuration is also dangerous. In this particular example, it shouldn’t do any harm as it only reads data, but imagine if we allowed the <code>rm</code> command instead. Suddenly, everything could be deleted without a password, as we globally allowed it (for that user). Most of the time you will want to allow password-less access only for a specific program.</p><p id="17b77955-515e-801d-b4e3-fc4bff38307b" class="">Let’s write a simple program in Go that reads network port usage:</p><pre id="17b77955-515e-8020-986c-d0d7bb615fd1" class="code"><code class="language-Go">// lsof-go.go
package main

import (
	"fmt"
	"os"
	"os/exec"
)

func main() {
	out, err := exec.Command("sudo", "lsof", "-nP", "-i4:80").Output()
	if err != nil {
		os.Exit(1) // error
	}

	fmt.Println(string(out))
}</code></pre><p id="17b77955-515e-8032-9689-d6aed52a4831" class="">Next, build and run the code. You should see the same output as before.</p><pre id="17b77955-515e-80bf-b010-e58cfc4c17bd" class="code"><code class="language-Bash">$ go build lsof-go.go
$ ./lsof-go
COMMAND   PID      USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
nginx   30212 jozefcipa    9u  IPv4 0xf57eb0bdeadfecb1      0t0  TCP *:80 (LISTEN)</code></pre><h2 id="17677955-515e-807b-881d-d7dacc3f50fb" class="">Adding our binary to sudoers</h2><p id="17b77955-515e-80e3-8580-e999bd8078b6" class="">Now, that we have our Go binary, we will update the <em>sudoers</em> file to allow password-less <em>sudo </em>for the binary only, instead of allowing <code>lsof</code> globally. We will do that again by using <code>visudo</code>.</p><pre id="17b77955-515e-806b-8eb5-e6ec9bad7a21" class="code"><code class="language-Bash">$ sudo visudo /etc/sudoers.d/test</code></pre><p id="17b77955-515e-8055-b1c4-d5d240eb05f9" class="">And change the file’s content to this:</p><pre id="17b77955-515e-80b4-a275-e219d80bbbc5" class="code"><code class="language-Bash">jozefcipa ALL=(ALL) NOPASSWD: /path/to/your/lsof-go</code></pre><p id="17b77955-515e-8052-8a34-cee2e358a336" class="">We registered our <code>lsof-go</code> binary in the <em>sudoers</em> file, so when we call <code>sudo ./lsof-go</code> it will give us the same result, but calling <code>sudo lsof</code> will require a password. This is because now the <code>lsof</code> command is no longer registered in the <em>sudoers </em>file, but <code>lsof-go</code> binary has password-less <em>sudo</em> access.</p><pre id="17b77955-515e-80e0-8581-db8e6b4a32f8" class="code"><code class="language-Bash">$ sudo ./lsof-go
COMMAND   PID      USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
nginx   30212 jozefcipa    9u  IPv4 0xf57eb0bdeadfecb1      0t0  TCP *:80 (LISTEN)

$ sudo lsof -nP -i4:80
Password:</code></pre><p id="17b77955-515e-8062-9ba7-ce41b3b23357" class="">Note that we have to run our binary with <code>sudo</code>. This is, naturally, needed as otherwise <em>sudoers</em> wouldn’t be used. </p><p id="17b77955-515e-80e8-96c2-c805faf1aaac" class="">However, this solution also has its downside. We successfully limited the scope of password-less access only to our <code>lsof-go</code> binary, but now we’re running the whole binary as <code>root</code>. This may be a problem when working on a larger application as all the commands will be run with the <code>root</code> privileges which is not only undesired but also dangerous (yeah, here we go again).</p><p id="17b77955-515e-800f-aa77-f0a140a23475" class="">Instead, we should only use <em>sudo</em> when necessary and still prefer a regular command version for the rest.</p><h2 id="17677955-515e-80b4-8bc8-c8cc0f7330f0" class="">Creating a helper script</h2><p id="17b77955-515e-8000-979a-e380844e1453" class="">We can extract the <code>lsof</code> command from our code into a new shell script. Then, we update the <em>sudoers</em> file again, and this time replace the <code>lsof-go</code> binary with the helper script. This script will now have password-less <em>sudo</em> privileges.</p><p id="17b77955-515e-807c-9fd5-c13f100c2e3f" class="">This allows us to keep running the <code>lsof-go</code> binary without <code>sudo</code> and whenever the code needs <code>root</code> privileges, it will call the <code>lsof-helper.sh</code> script (<em>Note</em>: don’t forget to<em> first run </em><em><code>chmod +x lsof-helper.sh</code></em><em> to make the script executable</em>).</p><pre id="17b77955-515e-80a0-b3ab-e6ce281d94ad" class="code"><code class="language-Bash">#!/bin/bash

sudo lsof -nP -i4:80</code></pre><p id="17b77955-515e-80fa-9abb-e283c7eb5224" class="">Now, in our Go code, we can update the command execution line as follows:</p><pre id="17b77955-515e-800e-aa6a-d3b8836ba4d6" class="code"><code class="language-Go">out, err := exec.Command("sudo", "./lsof-helper.sh").Output()</code></pre><p id="17077955-515e-8081-9fe8-e788649d5ae2" class="">However, there is one serious security vulnerability with this approach. Can you tell what is wrong?</p><h2 id="17b77955-515e-8063-80f8-f10a5bf9a0df" class="">Securing the helper script</h2><p id="17b77955-515e-80f2-ad5f-eafcf4140274" class="">If we open the helper script in a text editor, nothing stops us from modifying the file as we like. This is very dangerous as it poses a security vulnerability in our system, so a potential attacker could rewrite the file and add custom commands. That would result in gaining sudo privileges, as the <code>~/sudo-helper</code> file is registered in the <em>sudoers</em> file, so it has <em>root</em> access and so do all the commands it calls internally (!). Therefore, we must protect the file by forbidding any modifications by users. This can be easily done by setting the file owner to <code>root</code>:</p><pre id="17b77955-515e-80ee-bc5a-d943cd2670d0" class="code"><code class="language-Bash">$ sudo chown root ~/sudo-helper</code></pre><p id="17077955-515e-80d8-b1db-cd35bde829a3" class="">Now, if anyone wants to modify the file, they will have to enter a <em>sudo</em> password first. That means that our helper file is protected from abuse and will only have <em>sudo</em> access to the command that we have defined.</p><blockquote id="17b77955-515e-807f-87f8-cfd32f7359e8" class=""><em><strong>Note</strong></em><em>: Laravel Valet is a tool for PHP developers that creates real URLs instead of using </em><em><a href="http://localhost/">localhost</a></em><em> in the local environment. It uses a similar technique that we describe in this article, but with one significant difference - it </em><em><strong>does not protect </strong></em><em>the shell script. This means, as we could just see, everyone that installs Valet and uses the </em><em><code>trust</code></em><em> command becomes vulnerable to the </em><em><strong>privileges escalation </strong></em><em>threat!<br>I reported this on their Github but so far I haven’t received any answer.</em><br><br><em>Thus, this may be the best time to try out a new kid on the block - </em><em><strong>Novus</strong></em><em> - a local HTTPS proxy for a delightful developer experience that is language agnostic (no PHP ties), secure and fun to use. Go check it out on </em><em><a href="https://github.com/jozefcipa/novus">Github</a></em><em>. </em></blockquote><h2 id="17677955-515e-80fb-ab7b-f49d05b9e803" class="">Revoking access</h2><p id="17a77955-515e-8025-807c-ea6f2f5aee8a" class="">As granting sudo permissions, even though only in a limited scope, still weakens the overall security, it is always a good idea to provide a way for the users to opt<em>-</em>out, e.g. by defining a revoke command that will remove the sudoers configuration file, so the <em>sudo </em>password prompt will reappear.</p><h2 id="17b77955-515e-80f8-b166-c246c456452e" class="">That’s a wrap</h2><p id="17a77955-515e-80af-9d45-c0f294caad90" class="">In this article, we learned about the <em>sudoers</em> file and explored ways to allow password-less <em>sudo</em> access in our programs. We also discussed what vulnerabilities it exposes if not handled carefully and how to resolve them to not compromise the operating system security.</p><p id="17b77955-515e-8032-87cf-cb45efb35093" class="">I also implemented this in my open-source tool <a href="https://github.com/jozefcipa/novus">Novus</a>, so if you are curious about the internal details, make sure to check out how I implemented it there in the <code>trust</code> <a href="https://github.com/jozefcipa/novus/blob/main/cmd/trust.go">command</a>.</p><p id="17077955-515e-8032-a4bb-c725ca20654e" class="">
</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span>