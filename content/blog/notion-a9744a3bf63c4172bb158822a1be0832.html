---
title: Running HTTPS on localhost
tags:
  - nodejs
  - devops
  - docker
  - https
date: '2022-10-31T17:36:16.960Z'
slug: running-https-on-localhost
draft: false
---

<article id="a9744a3b-f63c-4172-bb15-8822a1be0832" class="page sans"><div class="page-body"><p id="253117b3-5622-46c2-a21c-d06b24cb8aeb" class="">The majority of websites nowadays are already using HTTPS. Security is very important in today’s world of the internet where you can buy stuff online, check your bank account, communicate with people, or just enjoy watching a movie. In each of these situations, it’s crucial that your data is encrypted and safely transferred across the internet so only your browser and the server can read the data without any 3rd party being able to intercept it along the way.</p><p id="fc1d8533-fd86-43c3-bf95-8a40957434c3" class="">HTTPS helps to achieve this by using <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">asymmetric cryptography</a> which encrypts all information exchanged between the client and the server.  This is done by generating a so-called digital certificate which is subsequently stored on the application server. Every client that wants to visit such a website, reads the certificate first and creates a <a href="https://www.cloudflare.com/learning/ssl/how-does-ssl-work/">TLS handshake</a> between them and the server. This way a secure connection is assured. </p><p id="9c5e3061-5d65-416d-beaf-4f7c6b5adfbc" class="">These certificates are issued by <strong>certificate authorities </strong>(CA) which are public organizations trusted by both owner of the certificate and the other party relying on it. They store, sign, and issue digital certificates. CAs verify the ownership of a website and then issue a certificate. This way whenever you see a padlock in your browser address bar, you can rest assured knowing that you’re actually seeing the original website instead of a tampered version.</p><p id="350691e0-9153-4fad-a4b9-78e15574683e" class=""><strong>Self-signed certificates</strong> are the exact opposite - they are generated by users themselves and can be created for free by using tools like <a href="https://en.wikipedia.org/wiki/OpenSSL">OpenSSL</a>. These can be useful in internal networks or test environments while developing an app. However, such certificates shouldn't be used in production (internet) environments as they are not signed by trusted authorities and thus not recognized by browsers.</p><h2 id="991738e3-1238-476b-a222-942f71d20596" class="">Generate an SSL certificate for <code>localhost</code></h2><p id="bb0c4e32-d9b5-4be9-a387-08dabd9b7f8b" class="">As <a href="http://localhost/"><code>localhost</code></a> doesn’t belong to anyone (in terms of domain ownership) and it’s not publicly accessible on the internet, public CAs<strong> cannot issue a certificate</strong> for it, as described in <a href="https://letsencrypt.org/docs/certificates-for-localhost/">this article</a> by Let’s Encrypt. One way to solve this issue would be to have a real domain that would point to <code>127.0.0.1</code>. There is an already existing website that does exactly that → <a href="https://readme.localtest.me/">readme.localtest.me</a>.</p><p id="a4b695e3-7ca8-412d-b663-62e8083108d5" class="">Another option would be to generate the above-mentioned self-signed SSL certificate. This is what we are going to do in this article.</p><p id="8104b888-d122-4551-aba7-fe5476a9d585" class="">As we already learned, we can generate a self-signed certificate using an <code>openssl</code> utility. But before that, we need to specify some necessary details about the certificate for <a href="https://en.wikipedia.org/wiki/Subject_Alternative_Name">SAN</a>. Without that<a href="https://stackoverflow.com/questions/7580508/getting-chrome-to-accept-self-signed-localhost-certificate"> some browsers could reject</a> opening a website. </p><p id="c0dfba88-3607-4223-ae03-16ed54738526" class="">
</p><pre id="db7474de-c1a4-475b-bff5-85a35b695dd4" class="code"><code># ./localhost.ext

[dn]
CN=localhost

[req]
distinguished_name = dn

[EXT]
subjectAltName=DNS:localhost
keyUsage=digitalSignature
extendedKeyUsage=serverAuth</code></pre><p id="32cee77b-0de4-4ef3-b7a6-01281fb61494" class="">
</p><p id="865d0462-8c6f-4b50-ae90-727da4a25b09" class="">The actual command will then look like this:</p><p id="292026e8-b1f9-4b8b-837f-240f96be63e1" class="">
</p><pre id="e687024a-824e-42a0-bf37-5a186a8e1af1" class="code"><code>openssl req -x509 \
  -out ./certs/cert.pem -keyout ./certs/cert.key \
  -newkey rsa:2048 -nodes -sha256 \
  -subj '/CN=localhost' -extensions EXT \
  -config &lt;(cat ./localhost.ext)</code></pre><h2 id="309a35d7-a7b4-43a9-ae65-4240ec5e5930" class="">Create a demo Node.js app</h2><p id="5489a424-7aaf-454a-8aff-f144bcbe58ea" class="">Now that we have the certificate ready, we need an app that we want to run on HTTPS. We will create a simple HTTP server written in Node.js that listens on port 3000 and returns a text message.</p><p id="47f4f4b5-bc67-4a5c-99ef-4836fcdf14bf" class="">
</p><pre id="39a9575a-57c5-44f4-baa6-0a717f58759d" class="code"><code>// main.js

const http = require('http')

const server = http.createServer((req, res) =&gt; {
  res.writeHead(200)
  res.end('Hello World!')
})

server.listen(3000)
console.log('Listening on 127.0.0.1:3000')</code></pre><p id="a4902f59-ef07-4391-87e5-af01d048d5d7" class="">
</p><p id="4a058dc0-868e-4b68-a0c4-954eeed63e5c" class="">You can check the response by running <code>node main.js</code> and opening <code>localhost:3000</code> in your browser.</p><p id="ceb71ec0-63b2-4d93-ab91-95f2f7a86e3a" class="">After checking that the code is working we can finally configure Nginx which will be used as a server for our app and will also take care of handling SSL. Theoretically, we don’t need Nginx as we could handle SSL termination in the app itself but since it’s a CPU-intensive task, it is s a good practice to offload this to a proper web server which also comes with other benefits.</p><h2 id="ec1d89b3-3f9d-444b-ae66-d15c7fbaee7b" class="">Configure Nginx</h2><p id="bbe74f27-e6e6-41d9-8a76-ac4e1b3c3888" class="">First, we need to install Nginx. The easiest way to do so is by using Docker. Here is a very simple <code>Dockerfile</code> that we’ll use to launch the server. </p><p id="1ac8ac24-273e-4f21-ba7a-6e295f2e0121" class="">
</p><pre id="b9fd395c-9062-4ac1-af86-725878c25232" class="code"><code>FROM nginx:1.21-alpine

COPY ./ssl.conf /etc/nginx/conf.d/ssl.conf
COPY ./sites.conf /etc/nginx/conf.d/default.conf

EXPOSE 3000</code></pre><p id="4100282a-3030-415e-adf0-7a2b031de97e" class="">
</p><p id="f8f9f25e-bf2b-47a8-8134-e1650f77e65f" class="">Before building the image, we have to create two files. In the first file - <code>sites.conf</code> we are going to configure the server behaviour. In our case, we just want to listen on port <code>443</code> (the default port for HTTPS) and we want to forward all incoming traffic to <a href="http://localhost:3000/"><code>localhost:3000</code></a>. </p><p id="d637ec31-31ce-4c7b-9216-ad6a4c7ac525" class="">Since we’re using Docker to run Nginx, we have to use the special URL to address the computer’s (host) port instead of the one inside the container. Therefore we set <a href="http://host.docker.internal/"><code>http://host.docker.internal</code></a> instead of <a href="http://localhost/"><code>http://localhost</code></a>.</p><p id="5b45f809-05f6-404d-b27c-129271cc2401" class="">
</p><pre id="c1dd973c-d4ac-463b-bc68-f3f86124eeb9" class="code"><code># sites.conf
server {
    listen  443 ssl;
    include /etc/nginx/conf.d/ssl.conf;

    location / {
        proxy_pass       http://host.docker.internal:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}</code></pre><p id="249427eb-ec13-49cb-a131-987732fc58ec" class="">
</p><p id="14e315ce-5751-4e53-9985-03aa1f759d05" class="">In the other file - <code>ssl.conf</code>, we just configure some SSL details. </p><p id="ef02b720-ba6b-41da-9508-2ca8b0eaba9d" class="">
</p><pre id="19bd7969-4a25-43e4-8d2b-92005b8a1c37" class="code"><code># ssl.conf
ssl_certificate                 /etc/nginx/ssl/cert.pem;
ssl_certificate_key             /etc/nginx/ssl/cert.key;

ssl_session_cache               shared:SSL:20m;
ssl_session_timeout             10m;
ssl_prefer_server_ciphers       on;
ssl_protocols                   TLSv1 TLSv1.1 TLSv1.2;
ssl_ciphers                     ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS;

add_header                      Strict-Transport-Security "max-age=31536000";</code></pre><p id="79c8522b-378f-43e9-85e0-c99f1a689f85" class="">
</p><p id="daeeed98-8d42-43fe-b5bd-4c67cf87600a" class="">Once we have the configuration ready, we can build the Docker image by calling</p><p id="9a5359f7-8442-48e6-94bc-4f765567805b" class="">
</p><pre id="7082e579-9f38-4d8b-bec4-d86347285db2" class="code"><code>docker build -t ssl-proxy . </code></pre><p id="de40e7fe-bcb1-4980-bdbe-7b0464d914c3" class="">
</p><p id="a547f68e-d3d0-4a97-8c1f-10b5017ffb8f" class="">When the build finishes, we can run the container. Make sure your node app is running!</p><p id="bd057d0d-19c7-4dad-8d92-00a700d0a695" class="">
</p><pre id="b7e5ba4a-f1f4-4fcf-9398-5e2f920140a5" class="code"><code>docker run -v "$(PWD)/certs:/etc/nginx/ssl" ssl-proxy</code></pre><p id="fcf8087d-45a5-422d-8761-335c2a7d8955" class="">
</p><p id="755cf547-c2c4-4475-b979-8df9b043df52" class="">If everything worked, you can now go to <a href="https://localhost/"><code>https://localhost</code></a> and after confirming the HTTPS certificate warning dialog in the browser you should see your Hello World message.</p><h2 id="8ed53291-1beb-46ac-b3ac-195fe8b97bed" class="">Specify a custom DNS name</h2><p id="1edf3661-469c-4572-b944-618a597beabb" class="">Now that we have it all working you might be thinking “hey, this is cool, but what if I don’t want <code>localhost</code>? is there any way I could specify a custom domain?”. I’m glad you asked! To make it work with a custom domain name, we have to configure DNS. We could either install some local DNS server or edit the special file called <code>/etc/hosts</code>. In this file, you can specify all custom domains and the IP address they should resolve to.</p><p id="702b2551-9e82-4c34-9986-517808495a4e" class="">Let’s say we want to access our web at the address <a href="https://my-cool-web.com/"><code>https://my-cool-web.com</code></a>. This address obviously doesn’t exist on the internet but we can trick our computer to resolve it anyway. Note that to edit the file you have to have <code>sudo</code> permissions, e.g. <code>sudo nano /etc/hosts</code>.</p><p id="a1861552-c948-4699-ac7f-7d0af785b55c" class="">
</p><pre id="02096a67-637f-4f9c-9982-83a762c14182" class="code"><code># /etc/hosts

# ...
# Append this at the end
127.0.0.1 my-cool-web.com</code></pre><p id="2905e8a7-b195-46e6-b56e-aa1e4fca6030" class="">
</p><p id="d4cd8fb6-f884-4cfb-a597-91a33824bdb0" class="">After editing and saving the file, the DNS should be configured and you can try to open the address <a href="https://my-cool-web.com/"><code>https://my-cool-web.com</code></a> in your browser.</p><p id="b8b82665-e16a-439d-8a76-a1059ab3e6c8" class="">
</p><figure id="f1454dc7-8e8e-4d35-ab31-ce0e3a808a51" class="image"><a href="/blog/img/connection-not-private.png"><img style="width:1426px" src="/blog/img/connection-not-private.png"></a></figure><p id="8ad56485-ad04-46f6-8eda-68b987544403" class="">
</p><p id="7cb5bd0d-f5ca-4b20-ad63-1e4a75f75303" class=""> After submitting the warning dialog you should be able to see the welcome message again, now on the custom domain.</p><p id="5b902b31-4d74-4563-bc33-1db65804edd1" class="">
</p><figure id="0f1b66c5-56b4-4e83-889f-7de6c936de58" class="image"><a href="/blog/img/domain.png"><img style="width:1142px" src="/blog/img/domain.png"></a></figure><p id="e2c74ec2-f288-4c9d-84a0-a4ae26289be6" class="">
</p><h2 id="c1359bb6-0cb4-4d81-923e-485d6b55bc55" class="">Add a subdomain</h2><p id="b07de1c3-f1d7-413e-b58b-230456d25482" class="">Let’s say we wanted to add a subdomain <code>subdomain.my-cool-web.com</code>. In order to do this we are going to update the Nginx configuration so it knows where and how to process the requests. We can do this by adding another <code>server</code> directive. Notice that we added a new directive <code>server_name</code> describing the actual domain the server should handle. The rest is almost the same, we just update the port the server should forward to for the subdomain.</p><p id="8c45524d-214d-4196-9e7c-2c27194ed6a5" class="">
</p><pre id="b3179692-0335-42a6-b16c-42b1ce7f9c54" class="code"><code>server {
    server_name my-cool-web.com;
    listen  443 ssl;
    include /etc/nginx/conf.d/ssl.conf;

    location / {
        proxy_pass       http://host.docker.internal:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

server {
    server_name subdomain.my-cool-web.com;
    listen  443 ssl;
    include /etc/nginx/conf.d/ssl.conf;

    location / {
        proxy_pass       http://host.docker.internal:4000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}</code></pre><p id="be5d9589-d369-4d10-b86f-0d5653e2461d" class="">
</p><p id="013a9a06-fc07-49c8-86bb-f20b7941e6f3" class="">If we’re not using some more sophisticated DNS server, we have to add the new URL to <code>/etc/hosts</code> file again, as it doesn’t support wildcards.</p><p id="61035650-5f54-4764-b96a-6451a7518f22" class="">
</p><pre id="5a7dbb88-2788-4625-aa8d-1d01fe67ec83" class="code"><code># /etc/hosts

127.0.0.1 my-cool-web.com
127.0.0.1 subdomain.my-cool-web.com</code></pre><p id="1825c2bc-7384-4b3e-b707-84861b31c75c" class="">
</p><p id="fdd340a7-0b5d-4a25-87e5-78ff0c6dbc4b" class="">To actually see a difference we can create a second Node.js server, which listens on port 4000 and shows a different message. </p><pre id="b13702da-d717-4329-9477-d8ddba93ac30" class="code"><code>// subdomain.js

const http = require('http')

const server = http.createServer((req, res) =&gt; {
  res.writeHead(200)
  res.end('Hello World from subdomain!')
})

server.listen(4000)
console.log('Listening on 127.0.0.1:4000')</code></pre><p id="ccdd8b37-3b30-4025-9a09-67a2a6dd620d" class="">
</p><p id="a95fec56-3910-47ec-850b-f00296edfbd9" class="">Make sure to rebuild the Docker image again (as we have changed the configuration), and run both Node.js scripts. Don’t forget to expose the newly added port 4000 in your Dockerfile!</p><p id="7bd75089-ef66-463a-ae40-91637d51a6ab" class="">Now, when you open <a href="http://subdomain.my-cool-web.com/"><code>subdomain.my-cool-web.com</code></a> you should see your subdomain message 🎉</p><p id="a2566b91-3706-4147-8e4d-e5d025b1339f" class="">
</p><figure id="df890e08-2c1b-4b3a-ade0-391ed4e0c491" class="image"><a href="/blog/img/subdomain.png"><img style="width:1228px" src="/blog/img/subdomain.png"></a></figure><p id="25d604c1-09eb-49b2-8e48-5878a12408ac" class="">
</p><p id="8c3d5e4a-7f3f-40fb-8cb7-a54c402f07a2" class="">And that is how you can make HTTPS work locally.</p><p id="c90293de-42bd-4ceb-86ed-447d31a2fe16" class="">You can find all the code on <a href="https://github.com/jozefcipa/https-localhost">Github</a>.</p></div></article>